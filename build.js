// Generated by Haxe 4.0.5
(function ($global) { "use strict";
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var Agent = function() {
	this.target = new _$Vector2_Base(0,0);
	this.position = new _$Vector2_Base(0,0);
};
var Context = function() {
	this.tileSize = 32;
	this.height = 32;
	this.width = 32;
	this.agents = [];
	this.world = [];
	var _g = 0;
	var _g1 = this.width * this.height;
	while(_g < _g1) {
		var i = _g++;
		this.world.push(0);
	}
	var _g2 = new haxe_ds_IntMap();
	var _g3 = new haxe_ds_IntMap();
	_g3.h[1] = 1.0;
	_g3.h[8] = 1.0;
	_g3.h[4] = 1.0;
	_g3.h[2] = 1.0;
	_g3.h[16] = astar_Graph.sqrt2;
	_g3.h[64] = astar_Graph.sqrt2;
	_g3.h[32] = astar_Graph.sqrt2;
	_g3.h[128] = astar_Graph.sqrt2;
	_g2.h[0] = _g3;
	var costs = _g2;
	this.graph = new astar_Graph(this.width,this.height,8);
	var _this = this.graph;
	var world = this.world;
	if(world.length != _this.width * _this.height) {
		throw new js__$Boot_HaxeError("Invalid world size, expected: " + _this.width + " x " + _this.height + " = " + _this.width * _this.height);
	}
	if(_this.pathCache != null) {
		_this.pathCache.reset(false);
	}
	_this.world = world;
	var _this1 = this.graph;
	if(_this1.pathCache != null) {
		_this1.pathCache.reset(false);
	}
	_this1.costs = costs;
};
Context.prototype = {
	createAgent: function() {
		var agent = new Agent();
		this.agents.push(agent);
		return agent;
	}
	,setTile: function(x,y,value) {
		this.world[y * this.width + x] = value;
	}
	,getTileX: function(worldX) {
		return worldX / this.tileSize | 0;
	}
	,getTileY: function(worldY) {
		return worldY / this.tileSize | 0;
	}
	,getWorldPosition: function(point) {
		var this1 = new _$Vector2_Base((point.x + 0.5) * this.tileSize,(point.y + 0.5) * this.tileSize);
		return this1;
	}
	,update: function() {
		var _g = 0;
		var _g1 = this.agents;
		while(_g < _g1.length) {
			var agent = _g1[_g];
			++_g;
			var tileX = agent.position.x / this.tileSize | 0;
			var tileY = agent.position.y / this.tileSize | 0;
			agent.pathResult = this.graph.solve(tileX,tileY,agent.target.x / this.tileSize | 0,agent.target.y / this.tileSize | 0);
		}
	}
};
var HxOverrides = function() { };
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Main = function() {
	this.tileSize = 32;
	var _gthis = this;
	this.width = window.innerWidth;
	this.height = window.innerHeight;
	var canvas = window.document.getElementsByTagName("canvas")[0];
	canvas.style.width = this.width + "px";
	canvas.style.height = this.height + "px";
	canvas.width = this.width;
	canvas.height = this.height;
	this.context2d = canvas.getContext("2d");
	this.context = new Context();
	var agent = this.context.createAgent();
	var this1 = agent.position;
	this1.x = 272;
	this1.y = 272;
	window.oncontextmenu = function(event) {
		event.preventDefault();
		return false;
	};
	window.onmousemove = window.onmousedown = function(event1) {
		var mx = event1.clientX;
		var my = event1.clientY;
		if(event1.buttons == 1) {
			var _g = 0;
			var _g1 = _gthis.context.agents;
			while(_g < _g1.length) {
				var agent1 = _g1[_g];
				++_g;
				var this2 = agent1.target;
				this2.x = mx;
				this2.y = my;
			}
			event1.preventDefault();
		}
		if(event1.buttons == 2) {
			var x = mx / _gthis.tileSize | 0;
			var y = my / _gthis.tileSize | 0;
			_gthis.context.setTile(x,y,1);
		}
		return false;
	};
	this.update(0);
};
Main.main = function() {
	new Main();
};
Main.prototype = {
	update: function(time) {
		this.context.update();
		this.context2d.fillStyle = "#888";
		this.context2d.fillRect(0,0,this.width,this.height);
		var world = this.context.world;
		this.context2d.fillStyle = "#833";
		var _g = 0;
		var _g1 = this.context.height;
		while(_g < _g1) {
			var y = _g++;
			var _g2 = 0;
			var _g11 = this.context.width;
			while(_g2 < _g11) {
				var x = _g2++;
				if(world[y * this.context.width + x] != 0) {
					this.context2d.fillRect(x * this.tileSize,y * this.tileSize,this.tileSize,this.tileSize);
				}
			}
		}
		this.context2d.lineWidth = 1;
		this.context2d.strokeStyle = "#aaa";
		var _g21 = 0;
		while(_g21 < 32) {
			var i = _g21++;
			var b = i * this.context.tileSize;
			var c = this.width;
			var d = i * this.context.tileSize;
			this.context2d.beginPath();
			this.context2d.moveTo(0,b);
			this.context2d.lineTo(c,d);
			this.context2d.stroke();
			var a = i * this.context.tileSize;
			var c1 = i * this.context.tileSize;
			var d1 = this.height;
			this.context2d.beginPath();
			this.context2d.moveTo(a,0);
			this.context2d.lineTo(c1,d1);
			this.context2d.stroke();
		}
		this.context2d.fillStyle = "blue";
		this.context2d.strokeStyle = "#fff";
		var radius = 16;
		var _g3 = 0;
		var _g12 = this.context.agents;
		while(_g3 < _g12.length) {
			var agent = _g12[_g3];
			++_g3;
			this.context2d.fillStyle = "blue";
			var x1 = agent.position.x;
			var y1 = agent.position.y;
			this.context2d.beginPath();
			this.context2d.arc(x1,y1,radius,0,2 * Math.PI);
			this.context2d.fill();
			this.context2d.fillStyle = "grey";
			var x2 = agent.position.x;
			var y2 = agent.position.y;
			this.context2d.beginPath();
			this.context2d.arc(x2,y2,radius * 0.7,0,2 * Math.PI);
			this.context2d.fill();
			this.context2d.strokeStyle = "lightgreen";
			if(agent.pathResult != null) {
				var path = agent.pathResult.path;
				if(path != null && path.length > 1) {
					var _g4 = 0;
					var _g13 = path.length - 1;
					while(_g4 < _g13) {
						var i1 = _g4++;
						var _this = this.context;
						var point = path[i1];
						var this1 = new _$Vector2_Base((point.x + 0.5) * _this.tileSize,(point.y + 0.5) * _this.tileSize);
						var from = this1;
						var _this1 = this.context;
						var point1 = path[i1 + 1];
						var this2 = new _$Vector2_Base((point1.x + 0.5) * _this1.tileSize,(point1.y + 0.5) * _this1.tileSize);
						var to = this2;
						var a1 = from.x;
						var b1 = from.y;
						var c2 = to.x;
						var d2 = to.y;
						this.context2d.beginPath();
						this.context2d.moveTo(a1,b1);
						this.context2d.lineTo(c2,d2);
						this.context2d.stroke();
					}
				}
			}
		}
		window.requestAnimationFrame($bind(this,this.update));
	}
	,drawTile: function(x,y) {
		this.context2d.fillRect(x * this.tileSize,y * this.tileSize,this.tileSize,this.tileSize);
	}
	,drawLine: function(a,b,c,d) {
		this.context2d.beginPath();
		this.context2d.moveTo(a,b);
		this.context2d.lineTo(c,d);
		this.context2d.stroke();
	}
	,drawCircle: function(x,y,r) {
		this.context2d.beginPath();
		this.context2d.arc(x,y,r,0,2 * Math.PI);
		this.context2d.fill();
	}
	,drawGrid: function() {
		var world = this.context.world;
		this.context2d.fillStyle = "#833";
		var _g = 0;
		var _g1 = this.context.height;
		while(_g < _g1) {
			var y = _g++;
			var _g2 = 0;
			var _g11 = this.context.width;
			while(_g2 < _g11) {
				var x = _g2++;
				if(world[y * this.context.width + x] != 0) {
					this.context2d.fillRect(x * this.tileSize,y * this.tileSize,this.tileSize,this.tileSize);
				}
			}
		}
		this.context2d.lineWidth = 1;
		this.context2d.strokeStyle = "#aaa";
		var _g21 = 0;
		while(_g21 < 32) {
			var i = _g21++;
			var b = i * this.context.tileSize;
			var c = this.width;
			var d = i * this.context.tileSize;
			this.context2d.beginPath();
			this.context2d.moveTo(0,b);
			this.context2d.lineTo(c,d);
			this.context2d.stroke();
			var a = i * this.context.tileSize;
			var c1 = i * this.context.tileSize;
			var d1 = this.height;
			this.context2d.beginPath();
			this.context2d.moveTo(a,0);
			this.context2d.lineTo(c1,d1);
			this.context2d.stroke();
		}
	}
};
var _$Vector2_Base = function(x,y) {
	this.x = x;
	this.y = y;
};
var _$Vector2_Vector2_$Impl_$ = {};
_$Vector2_Vector2_$Impl_$._new = function(x,y) {
	var this1 = new _$Vector2_Base(x,y);
	return this1;
};
_$Vector2_Vector2_$Impl_$.mulOp = function(a,b) {
	var this1 = new _$Vector2_Base(a.x * b,a.y * b);
	return this1;
};
_$Vector2_Vector2_$Impl_$.divOp = function(a,b) {
	var this1 = new _$Vector2_Base(a.x / b,a.y / b);
	return this1;
};
_$Vector2_Vector2_$Impl_$.addOp = function(a,b) {
	var this1 = new _$Vector2_Base(a.x + b.x,a.y + b.y);
	return this1;
};
_$Vector2_Vector2_$Impl_$.minOp = function(a,b) {
	var this1 = new _$Vector2_Base(a.x - b.x,a.y - b.y);
	return this1;
};
_$Vector2_Vector2_$Impl_$.getAngle = function(this1) {
	return Math.atan2(this1.y,this1.x);
};
_$Vector2_Vector2_$Impl_$.getLength = function(this1) {
	return Math.sqrt(this1.x * this1.x + this1.y * this1.y);
};
_$Vector2_Vector2_$Impl_$.getSquareLength = function(this1) {
	return this1.x * this1.x + this1.y * this1.y;
};
_$Vector2_Vector2_$Impl_$.set = function(this1,x,y) {
	this1.x = x;
	this1.y = y;
};
_$Vector2_Vector2_$Impl_$.copyFrom = function(this1,other) {
	this1.x = other.x;
	this1.y = other.y;
};
_$Vector2_Vector2_$Impl_$.add = function(this1,other) {
	this1.x += other.x;
	this1.y += other.y;
};
_$Vector2_Vector2_$Impl_$.multiply = function(this1,value) {
	this1.x *= value;
	this1.y *= value;
};
_$Vector2_Vector2_$Impl_$.divide = function(this1,value) {
	this1.x /= value;
	this1.y /= value;
};
_$Vector2_Vector2_$Impl_$.setDifference = function(this1,a,b) {
	this1.x = a.x - b.x;
	this1.y = a.y - b.y;
};
_$Vector2_Vector2_$Impl_$.normalize = function(this1) {
	var len = _$Vector2_Vector2_$Impl_$.getLength(this1);
	this1.x /= len;
	this1.y /= len;
};
_$Vector2_Vector2_$Impl_$.clone = function(this1) {
	var this2 = new _$Vector2_Base(this1.x,this1.y);
	return this2;
};
_$Vector2_Vector2_$Impl_$.getNormalized = function(this1) {
	var result = _$Vector2_Vector2_$Impl_$.clone(this1);
	_$Vector2_Vector2_$Impl_$.normalize(result);
	return result;
};
_$Vector2_Vector2_$Impl_$.setZero = function(this1) {
	this1.x = 0;
	this1.y = 0;
};
_$Vector2_Vector2_$Impl_$.dot = function(a,b) {
	return a.x * b.x + a.y * b.y;
};
_$Vector2_Vector2_$Impl_$.isSame = function(a,b) {
	if(a.x == b.x) {
		return a.y == b.y;
	} else {
		return false;
	}
};
_$Vector2_Vector2_$Impl_$.distance = function(a,b) {
	var this1 = new _$Vector2_Base(a.x - b.x,a.y - b.y);
	var delta = this1;
	return Math.sqrt(delta.x * delta.x + delta.y * delta.y);
};
var astar_Graph = function(width,height,movementDirection) {
	this.width = width;
	this.height = height;
	this.movementDirection = movementDirection;
	this.nodePool = new astar_types_PathNodePool();
	this.pathCache = null;
	this.cacheEnabled = false;
	this.openList = new astar_types_SortedPathNodeList();
	var this1 = [];
	this.closedList = this1;
};
astar_Graph.get_DefaultCosts = function() {
	var _g = new haxe_ds_IntMap();
	_g.h[1] = 1.0;
	_g.h[8] = 1.0;
	_g.h[4] = 1.0;
	_g.h[2] = 1.0;
	_g.h[16] = astar_Graph.sqrt2;
	_g.h[64] = astar_Graph.sqrt2;
	_g.h[32] = astar_Graph.sqrt2;
	_g.h[128] = astar_Graph.sqrt2;
	return _g;
};
astar_Graph.prototype = {
	setWorld: function(world) {
		if(world.length != this.width * this.height) {
			throw new js__$Boot_HaxeError("Invalid world size, expected: " + this.width + " x " + this.height + " = " + this.width * this.height);
		}
		if(this.pathCache != null) {
			this.pathCache.reset(false);
		}
		this.world = world;
	}
	,setCosts: function(costs) {
		if(this.pathCache != null) {
			this.pathCache.reset(false);
		}
		this.costs = costs;
	}
	,setHeuristicFunction: function(heuristicFunction) {
		if(this.pathCache != null) {
			this.pathCache.reset(false);
		}
		this.heuristicFunction = heuristicFunction;
	}
	,solve: function(startX,startY,endX,endY) {
		var result = new astar_SearchResult();
		if(startX == endX && startY == endY) {
			result.result = 3;
			return result;
		}
		if(!(startX >= 0 && startX < this.width && startY >= 0 && startY < this.height) || !(endX >= 0 && endX < this.width && endY >= 0 && endY < this.height)) {
			result.result = 4;
			return result;
		}
		if(!(startX >= 0 && startX < this.width && startY >= 0 && startY < this.height && this.costs.h.hasOwnProperty(this.world[startY * this.width + startX])) || !(endX >= 0 && endX < this.width && endY >= 0 && endY < this.height && this.costs.h.hasOwnProperty(this.world[endY * this.width + endX]))) {
			result.result = 5;
			return result;
		}
		var pathEndNode = this.findPath(startX,startY,endX,endY,result);
		if(pathEndNode != null) {
			result.setResultPath(pathEndNode);
			if(this.cacheEnabled) {
				this.pathCache.addSolution(pathEndNode);
			}
			return result;
		}
		result.result = 2;
		return result;
	}
	,configureCache: function(enabled,size) {
		if(enabled) {
			this.cacheEnabled = true;
			if(this.pathCache == null) {
				if(size == null) {
					throw new js__$Boot_HaxeError("You need to specify a cache size when enabling path caching.");
				}
				this.pathCache = new astar_cache_PathCache(size);
			} else if(size != null) {
				if(this.pathCache != null) {
					this.pathCache.reset(false);
				}
				this.pathCache.cache = new astar_cache_BubbleList_$astar_$cache_$CachedPath(size);
			}
		} else {
			this.cacheEnabled = false;
		}
	}
	,resetCache: function(freeMemory) {
		if(freeMemory == null) {
			freeMemory = false;
		}
		if(this.pathCache != null) {
			this.pathCache.reset(freeMemory);
		}
	}
	,findPath: function(startX,startY,endX,endY,result) {
		this.goalX = endX;
		this.goalY = endY;
		var _this = this.openList;
		var pool = null;
		if(pool != null) {
			_this.clearRecursive(_this.root,pool);
		}
		_this.root = null;
		_this.min = null;
		_this.size = 0;
		var this1 = this.closedList;
		var pool1 = this.nodePool;
		var _g = 0;
		var _g1 = this1.length;
		while(_g < _g1) {
			var x = _g++;
			if(this1[x] != null) {
				var _g2 = 0;
				var _g11 = this1[x].length;
				while(_g2 < _g11) {
					var y = _g2++;
					if(x < this1.length && this1[x] != null) {
						if(pool1 != null && this1[x][y] != null) {
							var node = this1[x][y];
							node.next = pool1.head;
							pool1.head = node;
							pool1.size++;
						}
						this1[x][y] = null;
					}
				}
			}
		}
		var _this1 = this.nodePool;
		var node1;
		if(_this1.head == null) {
			node1 = new astar_types_PathNode();
		} else {
			var node2 = _this1.head;
			_this1.head = _this1.head.next;
			node2.next = null;
			_this1.size--;
			node2.adjacentCount = -1;
			node2.discovered = node2.visited = false;
			node2.next = node2.left = node2.right = node2.parent = null;
			node1 = node2;
		}
		node1.x = startX;
		node1.y = startY;
		node1.costFromStart = 0;
		node1.estimatedCostToGoal = 0;
		node1.previous = null;
		var startingNode = node1;
		this.openList.insert(startingNode);
		var this2 = this.closedList;
		if(this2.length <= startingNode.x) {
			this2.length = startingNode.x + 1;
		}
		if(this2[startingNode.x] == null) {
			this2[startingNode.x] = [];
		}
		if(this2[startingNode.x].length <= startingNode.y) {
			this2[startingNode.x].length = startingNode.y + 1;
		}
		this2[startingNode.x][startingNode.y] = startingNode;
		while(this.openList.size != 0) {
			var node3 = this.openList.popNext();
			if(node3.x == this.goalX && node3.y == this.goalY) {
				return node3;
			}
			if(this.cacheEnabled && result != null) {
				var cacheResult = this.pathCache.solve(node3.x,node3.y,endX,endY,result);
				switch(cacheResult) {
				case 0:
					return node3;
				case 2:
					return null;
				default:
				}
			}
			this.tryAddNeighbor(node3,1);
			this.tryAddNeighbor(node3,2);
			this.tryAddNeighbor(node3,8);
			this.tryAddNeighbor(node3,4);
			if((this.movementDirection & (2 | 8 | 4)) > 0) {
				this.tryAddNeighbor(node3,16);
				this.tryAddNeighbor(node3,32);
				this.tryAddNeighbor(node3,64);
				this.tryAddNeighbor(node3,128);
			}
			node3.visited = true;
		}
		if(this.cacheEnabled) {
			this.pathCache.addNoSolution(startX,startY,endX,endY);
		}
		return null;
	}
	,addNeighbors: function(node) {
		this.tryAddNeighbor(node,1);
		this.tryAddNeighbor(node,2);
		this.tryAddNeighbor(node,8);
		this.tryAddNeighbor(node,4);
		if((this.movementDirection & (2 | 8 | 4)) > 0) {
			this.tryAddNeighbor(node,16);
			this.tryAddNeighbor(node,32);
			this.tryAddNeighbor(node,64);
			this.tryAddNeighbor(node,128);
		}
	}
	,tryAddNeighbor: function(node,direction) {
		var neighborX;
		switch(direction) {
		case 4:case 32:case 128:
			neighborX = 1;
			break;
		case 2:case 16:case 64:
			neighborX = -1;
			break;
		default:
			neighborX = 0;
		}
		var neighborX1 = node.x + neighborX;
		var neighborY;
		switch(direction) {
		case 1:case 16:case 32:
			neighborY = 1;
			break;
		case 8:case 64:case 128:
			neighborY = -1;
			break;
		default:
			neighborY = 0;
		}
		var neighborY1 = node.y + neighborY;
		if(!(neighborX1 >= 0 && neighborX1 < this.width && neighborY1 >= 0 && neighborY1 < this.height)) {
			return;
		}
		var neighborVal = this.world[neighborY1 * this.width + neighborX1];
		var cv = this.world[neighborY1 * this.width + neighborX1];
		var hasCostInDirection = this.costs.h.hasOwnProperty(cv) && this.costs.h[cv].h.hasOwnProperty(direction);
		var tmp;
		if(!hasCostInDirection) {
			tmp = false;
		} else if((direction & (16 | 32 | 64 | 128)) <= 0) {
			tmp = true;
		} else if(this.movementDirection == 2) {
			tmp = true;
		} else if(this.movementDirection == 4) {
			var x;
			switch(direction) {
			case 4:case 32:case 128:
				x = 1;
				break;
			case 2:case 16:case 64:
				x = -1;
				break;
			default:
				x = 0;
			}
			var x1 = neighborX1 + x;
			if(!(x1 >= 0 && x1 < this.width && neighborY1 >= 0 && neighborY1 < this.height && this.costs.h.hasOwnProperty(this.world[neighborY1 * this.width + x1]))) {
				var y;
				switch(direction) {
				case 1:case 16:case 32:
					y = 1;
					break;
				case 8:case 64:case 128:
					y = -1;
					break;
				default:
					y = 0;
				}
				var y1 = neighborY1 + y;
				tmp = neighborX1 >= 0 && neighborX1 < this.width && y1 >= 0 && y1 < this.height && this.costs.h.hasOwnProperty(this.world[y1 * this.width + neighborX1]);
			} else {
				tmp = true;
			}
		} else if(this.movementDirection == 8) {
			var x2;
			switch(direction) {
			case 4:case 32:case 128:
				x2 = 1;
				break;
			case 2:case 16:case 64:
				x2 = -1;
				break;
			default:
				x2 = 0;
			}
			var x3 = neighborX1 + x2;
			if(x3 >= 0 && x3 < this.width && neighborY1 >= 0 && neighborY1 < this.height && this.costs.h.hasOwnProperty(this.world[neighborY1 * this.width + x3])) {
				var y2;
				switch(direction) {
				case 1:case 16:case 32:
					y2 = 1;
					break;
				case 8:case 64:case 128:
					y2 = -1;
					break;
				default:
					y2 = 0;
				}
				var y3 = neighborY1 + y2;
				tmp = neighborX1 >= 0 && neighborX1 < this.width && y3 >= 0 && y3 < this.height && this.costs.h.hasOwnProperty(this.world[y3 * this.width + neighborX1]);
			} else {
				tmp = false;
			}
		} else {
			throw new js__$Boot_HaxeError("Should not be here");
		}
		if(!tmp) {
			return;
		}
		if(!(neighborX1 >= 0 && neighborX1 < this.width && neighborY1 >= 0 && neighborY1 < this.height && this.costs.h.hasOwnProperty(this.world[neighborY1 * this.width + neighborX1]))) {
			return;
		}
		var costFromStart = node.costFromStart + this.costs.h[neighborVal].h[direction];
		var toX = this.goalX;
		var toY = this.goalY;
		if(this.heuristicFunction == null) {
			var tmp1;
			switch(this.movementDirection) {
			case 1:
				tmp1 = new astar_cost_ManhattanDistance(this.getMinCost(1 | 2 | 4 | 8));
				break;
			case 2:case 4:case 8:
				tmp1 = new astar_cost_DiagonalDistance(this.getMinCost(1 | 2 | 4 | 8),this.getMinCost(32 | 16 | 128 | 64));
				break;
			default:
				throw new js__$Boot_HaxeError("Invalid movement direction.");
			}
			this.heuristicFunction = tmp1;
		}
		var costEstimateToGoal = this.heuristicFunction.getEstimate(neighborX1,neighborY1,toX,toY);
		var this1 = this.closedList;
		if(this1.length > neighborX1 && this1[neighborX1] != null && this1[neighborX1].length > neighborY1 && this1[neighborX1][neighborY1] != null && this1[neighborX1][neighborY1].discovered) {
			var existing = this.closedList[neighborX1][neighborY1];
			if(existing.costFromStart <= costFromStart) {
				return;
			} else {
				this.openList.remove(existing);
				var this2 = this.closedList;
				var x4 = existing.x;
				var y4 = existing.y;
				var pool = this.nodePool;
				if(x4 < this2.length && this2[x4] != null) {
					if(pool != null && this2[x4][y4] != null) {
						var node1 = this2[x4][y4];
						node1.next = pool.head;
						pool.head = node1;
						pool.size++;
					}
					this2[x4][y4] = null;
				}
			}
		}
		var _this = this.nodePool;
		var node2;
		if(_this.head == null) {
			node2 = new astar_types_PathNode();
		} else {
			var node3 = _this.head;
			_this.head = _this.head.next;
			node3.next = null;
			_this.size--;
			node3.adjacentCount = -1;
			node3.discovered = node3.visited = false;
			node3.next = node3.left = node3.right = node3.parent = null;
			node2 = node3;
		}
		node2.x = neighborX1;
		node2.y = neighborY1;
		node2.costFromStart = costFromStart;
		node2.estimatedCostToGoal = costEstimateToGoal;
		node2.previous = node;
		var neighbor = node2;
		neighbor.discovered = true;
		this.openList.insert(neighbor);
		var this3 = this.closedList;
		if(this3.length <= neighbor.x) {
			this3.length = neighbor.x + 1;
		}
		if(this3[neighbor.x] == null) {
			this3[neighbor.x] = [];
		}
		if(this3[neighbor.x].length <= neighbor.y) {
			this3[neighbor.x].length = neighbor.y + 1;
		}
		this3[neighbor.x][neighbor.y] = neighbor;
	}
	,getCellValue: function(x,y) {
		return this.world[y * this.width + x];
	}
	,getHeuristicDistance: function(fromX,fromY,toX,toY) {
		if(this.heuristicFunction == null) {
			var tmp;
			switch(this.movementDirection) {
			case 1:
				tmp = new astar_cost_ManhattanDistance(this.getMinCost(1 | 2 | 4 | 8));
				break;
			case 2:case 4:case 8:
				tmp = new astar_cost_DiagonalDistance(this.getMinCost(1 | 2 | 4 | 8),this.getMinCost(32 | 16 | 128 | 64));
				break;
			default:
				throw new js__$Boot_HaxeError("Invalid movement direction.");
			}
			this.heuristicFunction = tmp;
		}
		return this.heuristicFunction.getEstimate(fromX,fromY,toX,toY);
	}
	,inBounds: function(x,y) {
		if(x >= 0 && x < this.width && y >= 0) {
			return y < this.height;
		} else {
			return false;
		}
	}
	,isCellPassable: function(x,y) {
		if(x >= 0 && x < this.width && y >= 0 && y < this.height) {
			return this.costs.h.hasOwnProperty(this.world[y * this.width + x]);
		} else {
			return false;
		}
	}
	,isCellPassableInDirection: function(x,y,direction) {
		var cv = this.world[y * this.width + x];
		var hasCostInDirection = this.costs.h.hasOwnProperty(cv) && this.costs.h[cv].h.hasOwnProperty(direction);
		if(!hasCostInDirection) {
			return false;
		} else if((direction & (16 | 32 | 64 | 128)) <= 0) {
			return true;
		} else if(this.movementDirection == 2) {
			return true;
		} else if(this.movementDirection == 4) {
			var x1;
			switch(direction) {
			case 4:case 32:case 128:
				x1 = 1;
				break;
			case 2:case 16:case 64:
				x1 = -1;
				break;
			default:
				x1 = 0;
			}
			var x2 = x + x1;
			if(!(x2 >= 0 && x2 < this.width && y >= 0 && y < this.height && this.costs.h.hasOwnProperty(this.world[y * this.width + x2]))) {
				var y1;
				switch(direction) {
				case 1:case 16:case 32:
					y1 = 1;
					break;
				case 8:case 64:case 128:
					y1 = -1;
					break;
				default:
					y1 = 0;
				}
				var y2 = y + y1;
				if(x >= 0 && x < this.width && y2 >= 0 && y2 < this.height) {
					return this.costs.h.hasOwnProperty(this.world[y2 * this.width + x]);
				} else {
					return false;
				}
			} else {
				return true;
			}
		} else if(this.movementDirection == 8) {
			var x3;
			switch(direction) {
			case 4:case 32:case 128:
				x3 = 1;
				break;
			case 2:case 16:case 64:
				x3 = -1;
				break;
			default:
				x3 = 0;
			}
			var x4 = x + x3;
			if(x4 >= 0 && x4 < this.width && y >= 0 && y < this.height && this.costs.h.hasOwnProperty(this.world[y * this.width + x4])) {
				var y3;
				switch(direction) {
				case 1:case 16:case 32:
					y3 = 1;
					break;
				case 8:case 64:case 128:
					y3 = -1;
					break;
				default:
					y3 = 0;
				}
				var y4 = y + y3;
				if(x >= 0 && x < this.width && y4 >= 0 && y4 < this.height) {
					return this.costs.h.hasOwnProperty(this.world[y4 * this.width + x]);
				} else {
					return false;
				}
			} else {
				return false;
			}
		} else {
			throw new js__$Boot_HaxeError("Should not be here");
		}
	}
	,getMinCost: function(directions) {
		var found = false;
		var min = 0;
		var _g = new haxe_iterators_MapKeyValueIterator(this.costs);
		while(_g.hasNext()) {
			var _g1 = _g.next();
			var _ = _g1.key;
			var dirCosts = _g1.value;
			var _g2 = new haxe_iterators_MapKeyValueIterator(dirCosts);
			while(_g2.hasNext()) {
				var _g3 = _g2.next();
				var dir = _g3.key;
				var cost = _g3.value;
				if((dir & directions) > 0) {
					if(!found || cost < min) {
						found = true;
						min = cost;
					}
				}
			}
		}
		return min;
	}
};
var astar__$MovementDirection_MovementDirection_$Impl_$ = {};
astar__$MovementDirection_MovementDirection_$Impl_$.isDiagonal = function(this1) {
	return (this1 & (2 | 8 | 4)) > 0;
};
var astar_SearchResult = function() {
	this.path = null;
	this.cost = 0;
	this.steps = 0;
	this.result = 0;
};
astar_SearchResult.prototype = {
	setResultPath: function(node) {
		this.result = 1;
		if(this.path == null) {
			this.path = [];
		}
		this.cost += node.costFromStart;
		if(this.path.length > 0 && this.path[0].x == node.x && this.path[0].y == node.y) {
			node = node.previous;
		}
		while(node != null) {
			this.path.splice(0,0,{ x : node.x, y : node.y});
			this.steps++;
			node = node.previous;
		}
	}
	,appendCachedNodes: function(node) {
		if(this.path == null) {
			this.path = [];
		}
		this.cost += node.costToEnd;
		while(node != null) {
			this.path.push({ x : node.x, y : node.y});
			this.steps++;
			node = node.next;
		}
	}
};
var astar_cache_BubbleList = function(capacity) {
	this.capacity = capacity;
	this.length = 0;
	this.head = null;
	this.middle = null;
	this.tail = null;
};
astar_cache_BubbleList.prototype = {
	insert: function(elem) {
		if(this.head == null) {
			this.head = elem;
			this.middle = elem;
			this.tail = elem;
			elem.next = elem.previous = null;
		} else {
			if(this.length % 2 == 1) {
				var a = this.middle.previous;
				var b = this.middle;
				elem.previous = a;
				if(a != null) {
					a.next = elem;
				}
				elem.next = b;
				if(b != null) {
					b.previous = elem;
				}
				if(elem.previous == null) {
					this.head = elem;
				}
				if(elem.next == null) {
					this.tail = elem;
				}
			} else {
				var a1 = this.middle;
				var b1 = this.middle.next;
				elem.previous = a1;
				if(a1 != null) {
					a1.next = elem;
				}
				elem.next = b1;
				if(b1 != null) {
					b1.previous = elem;
				}
				if(elem.previous == null) {
					this.head = elem;
				}
				if(elem.next == null) {
					this.tail = elem;
				}
			}
			this.middle = elem;
		}
		this.length++;
		if(this.length > this.capacity) {
			var tmp;
			if(this.tail == null) {
				tmp = null;
			} else {
				var elem1 = this.tail;
				if(this.head == null) {
					throw new js__$Boot_HaxeError("Removing from empty list.");
				} else if(this.tail == this.head) {
					this.length = 0;
					this.head = null;
					this.middle = null;
					this.tail = null;
				} else {
					this.length--;
					if(elem1.previous != null) {
						elem1.previous.next = elem1.next;
					}
					if(elem1.next != null) {
						elem1.next.previous = elem1.previous;
					}
					if(elem1 == this.tail) {
						if(this.length % 2 == 0) {
							this.middle = this.middle.previous;
						}
					} else if(elem1 == this.middle) {
						this.middle = this.middle.next;
					} else if(this.length % 2 == 0) {
						this.middle = this.middle.previous;
					} else {
						this.middle = this.middle.next;
					}
					if(elem1 == this.tail) {
						this.tail = elem1.previous;
					}
					if(elem1 == this.head) {
						this.head = elem1.next;
					}
				}
				elem1.next = elem1.previous = null;
				tmp = elem1;
			}
			return tmp;
		} else {
			return null;
		}
	}
	,bubble: function(elem) {
		if(elem.previous == null) {
			return;
		}
		elem.previous.next = elem.next;
		if(elem.next != null) {
			elem.next.previous = elem.previous;
		}
		var a = elem.previous.previous;
		var b = elem.previous;
		elem.previous = a;
		if(a != null) {
			a.next = elem;
		}
		elem.next = b;
		if(b != null) {
			b.previous = elem;
		}
		if(elem.previous == null) {
			this.head = elem;
		}
		if(elem.next == null) {
			this.tail = elem;
		}
		if(elem.next == this.middle) {
			this.middle = elem;
		} else if(elem == this.middle) {
			this.middle = elem.next;
		}
	}
	,pop: function() {
		if(this.tail == null) {
			return null;
		} else {
			var elem = this.tail;
			if(this.head == null) {
				throw new js__$Boot_HaxeError("Removing from empty list.");
			} else if(this.tail == this.head) {
				this.length = 0;
				this.head = null;
				this.middle = null;
				this.tail = null;
			} else {
				this.length--;
				if(elem.previous != null) {
					elem.previous.next = elem.next;
				}
				if(elem.next != null) {
					elem.next.previous = elem.previous;
				}
				if(elem == this.tail) {
					if(this.length % 2 == 0) {
						this.middle = this.middle.previous;
					}
				} else if(elem == this.middle) {
					this.middle = this.middle.next;
				} else if(this.length % 2 == 0) {
					this.middle = this.middle.previous;
				} else {
					this.middle = this.middle.next;
				}
				if(elem == this.tail) {
					this.tail = elem.previous;
				}
				if(elem == this.head) {
					this.head = elem.next;
				}
			}
			elem.next = elem.previous = null;
			return elem;
		}
	}
	,last: function() {
		return this.tail;
	}
	,remove: function(elem) {
		if(this.head == null) {
			throw new js__$Boot_HaxeError("Removing from empty list.");
		} else if(this.tail == this.head) {
			this.length = 0;
			this.head = null;
			this.middle = null;
			this.tail = null;
		} else {
			this.length--;
			if(elem.previous != null) {
				elem.previous.next = elem.next;
			}
			if(elem.next != null) {
				elem.next.previous = elem.previous;
			}
			if(elem == this.tail) {
				if(this.length % 2 == 0) {
					this.middle = this.middle.previous;
				}
			} else if(elem == this.middle) {
				this.middle = this.middle.next;
			} else if(this.length % 2 == 0) {
				this.middle = this.middle.previous;
			} else {
				this.middle = this.middle.next;
			}
			if(elem == this.tail) {
				this.tail = elem.previous;
			}
			if(elem == this.head) {
				this.head = elem.next;
			}
		}
		elem.next = elem.previous = null;
	}
	,insertBetween: function(a,b,elem) {
		elem.previous = a;
		if(a != null) {
			a.next = elem;
		}
		elem.next = b;
		if(b != null) {
			b.previous = elem;
		}
		if(elem.previous == null) {
			this.head = elem;
		}
		if(elem.next == null) {
			this.tail = elem;
		}
	}
	,reset: function() {
		this.length = 0;
		this.head = null;
		this.middle = null;
		this.tail = null;
	}
};
var astar_cache_BubbleList_$astar_$cache_$CachedPath = function(capacity) {
	this.capacity = capacity;
	this.length = 0;
	this.head = null;
	this.middle = null;
	this.tail = null;
};
astar_cache_BubbleList_$astar_$cache_$CachedPath.prototype = {
	insert: function(elem) {
		if(this.head == null) {
			this.head = elem;
			this.middle = elem;
			this.tail = elem;
			elem.next = elem.previous = null;
		} else {
			if(this.length % 2 == 1) {
				var a = this.middle.previous;
				var b = this.middle;
				elem.previous = a;
				if(a != null) {
					a.next = elem;
				}
				elem.next = b;
				if(b != null) {
					b.previous = elem;
				}
				if(elem.previous == null) {
					this.head = elem;
				}
				if(elem.next == null) {
					this.tail = elem;
				}
			} else {
				var a1 = this.middle;
				var b1 = this.middle.next;
				elem.previous = a1;
				if(a1 != null) {
					a1.next = elem;
				}
				elem.next = b1;
				if(b1 != null) {
					b1.previous = elem;
				}
				if(elem.previous == null) {
					this.head = elem;
				}
				if(elem.next == null) {
					this.tail = elem;
				}
			}
			this.middle = elem;
		}
		this.length++;
		if(this.length > this.capacity) {
			var tmp;
			if(this.tail == null) {
				tmp = null;
			} else {
				var elem1 = this.tail;
				if(this.head == null) {
					throw new js__$Boot_HaxeError("Removing from empty list.");
				} else if(this.tail == this.head) {
					this.length = 0;
					this.head = null;
					this.middle = null;
					this.tail = null;
				} else {
					this.length--;
					if(elem1.previous != null) {
						elem1.previous.next = elem1.next;
					}
					if(elem1.next != null) {
						elem1.next.previous = elem1.previous;
					}
					if(elem1 == this.tail) {
						if(this.length % 2 == 0) {
							this.middle = this.middle.previous;
						}
					} else if(elem1 == this.middle) {
						this.middle = this.middle.next;
					} else if(this.length % 2 == 0) {
						this.middle = this.middle.previous;
					} else {
						this.middle = this.middle.next;
					}
					if(elem1 == this.tail) {
						this.tail = elem1.previous;
					}
					if(elem1 == this.head) {
						this.head = elem1.next;
					}
				}
				elem1.next = elem1.previous = null;
				tmp = elem1;
			}
			return tmp;
		} else {
			return null;
		}
	}
	,bubble: function(elem) {
		if(elem.previous == null) {
			return;
		}
		elem.previous.next = elem.next;
		if(elem.next != null) {
			elem.next.previous = elem.previous;
		}
		var a = elem.previous.previous;
		var b = elem.previous;
		elem.previous = a;
		if(a != null) {
			a.next = elem;
		}
		elem.next = b;
		if(b != null) {
			b.previous = elem;
		}
		if(elem.previous == null) {
			this.head = elem;
		}
		if(elem.next == null) {
			this.tail = elem;
		}
		if(elem.next == this.middle) {
			this.middle = elem;
		} else if(elem == this.middle) {
			this.middle = elem.next;
		}
	}
	,pop: function() {
		if(this.tail == null) {
			return null;
		} else {
			var elem = this.tail;
			if(this.head == null) {
				throw new js__$Boot_HaxeError("Removing from empty list.");
			} else if(this.tail == this.head) {
				this.length = 0;
				this.head = null;
				this.middle = null;
				this.tail = null;
			} else {
				this.length--;
				if(elem.previous != null) {
					elem.previous.next = elem.next;
				}
				if(elem.next != null) {
					elem.next.previous = elem.previous;
				}
				if(elem == this.tail) {
					if(this.length % 2 == 0) {
						this.middle = this.middle.previous;
					}
				} else if(elem == this.middle) {
					this.middle = this.middle.next;
				} else if(this.length % 2 == 0) {
					this.middle = this.middle.previous;
				} else {
					this.middle = this.middle.next;
				}
				if(elem == this.tail) {
					this.tail = elem.previous;
				}
				if(elem == this.head) {
					this.head = elem.next;
				}
			}
			elem.next = elem.previous = null;
			return elem;
		}
	}
	,last: function() {
		return this.tail;
	}
	,remove: function(elem) {
		if(this.head == null) {
			throw new js__$Boot_HaxeError("Removing from empty list.");
		} else if(this.tail == this.head) {
			this.length = 0;
			this.head = null;
			this.middle = null;
			this.tail = null;
		} else {
			this.length--;
			if(elem.previous != null) {
				elem.previous.next = elem.next;
			}
			if(elem.next != null) {
				elem.next.previous = elem.previous;
			}
			if(elem == this.tail) {
				if(this.length % 2 == 0) {
					this.middle = this.middle.previous;
				}
			} else if(elem == this.middle) {
				this.middle = this.middle.next;
			} else if(this.length % 2 == 0) {
				this.middle = this.middle.previous;
			} else {
				this.middle = this.middle.next;
			}
			if(elem == this.tail) {
				this.tail = elem.previous;
			}
			if(elem == this.head) {
				this.head = elem.next;
			}
		}
		elem.next = elem.previous = null;
	}
	,insertBetween: function(a,b,elem) {
		elem.previous = a;
		if(a != null) {
			a.next = elem;
		}
		elem.next = b;
		if(b != null) {
			b.previous = elem;
		}
		if(elem.previous == null) {
			this.head = elem;
		}
		if(elem.next == null) {
			this.tail = elem;
		}
	}
	,reset: function() {
		this.length = 0;
		this.head = null;
		this.middle = null;
		this.tail = null;
	}
};
var astar_cache_CachedPath = function() {
	this.reset();
};
astar_cache_CachedPath.prototype = {
	reset: function() {
		this.startNode = null;
		this.hash = 0;
	}
	,matches: function(startX,startY,endX,endY) {
		if(this.startX == startX && this.startY == startY && this.endX == endX) {
			return this.endY == endY;
		} else {
			return false;
		}
	}
	,hasSolution: function() {
		return this.startNode != null;
	}
};
var astar_cache_CachedPathNode = function() {
	this.next = null;
};
astar_cache_CachedPathNode.prototype = {
	reset: function() {
		this.next = null;
	}
};
var astar_types_Pool_$astar_$cache_$CachedPathNode = function() {
	this.head = null;
	this.size = 0;
};
astar_types_Pool_$astar_$cache_$CachedPathNode.prototype = {
	get: function() {
		if(this.head == null) {
			return this.create();
		}
		var node = this.head;
		this.head = this.head.next;
		node.next = null;
		this.size--;
		node.next = null;
		return node;
	}
	,put: function(node) {
		node.next = this.head;
		this.head = node;
		this.size++;
	}
	,fill: function(amount) {
		var _g = 0;
		var _g1 = amount;
		while(_g < _g1) {
			var i = _g++;
			var node = this.create();
			node.next = this.head;
			this.head = node;
			this.size++;
		}
	}
	,getSize: function() {
		return this.size;
	}
	,clear: function() {
		this.head = null;
		this.size = 0;
	}
	,create: function() {
		throw new js__$Boot_HaxeError("Using abstract pool create()");
	}
};
var astar_cache_CachedPathNodePool = function() {
	astar_types_Pool_$astar_$cache_$CachedPathNode.call(this);
};
astar_cache_CachedPathNodePool.__super__ = astar_types_Pool_$astar_$cache_$CachedPathNode;
astar_cache_CachedPathNodePool.prototype = $extend(astar_types_Pool_$astar_$cache_$CachedPathNode.prototype,{
	getCachedPathNode: function(x,y,next,costToEnd) {
		var node;
		if(this.head == null) {
			node = new astar_cache_CachedPathNode();
		} else {
			var node1 = this.head;
			this.head = this.head.next;
			node1.next = null;
			this.size--;
			node1.next = null;
			node = node1;
		}
		node.x = x;
		node.y = y;
		node.costToEnd = costToEnd;
		node.next = next;
		return node;
	}
	,create: function() {
		return new astar_cache_CachedPathNode();
	}
});
var astar_types_Pool_$astar_$cache_$CachedPath = function() {
	this.head = null;
	this.size = 0;
};
astar_types_Pool_$astar_$cache_$CachedPath.prototype = {
	get: function() {
		if(this.head == null) {
			return this.create();
		}
		var node = this.head;
		this.head = this.head.next;
		node.next = null;
		this.size--;
		node.reset();
		return node;
	}
	,put: function(node) {
		node.next = this.head;
		this.head = node;
		this.size++;
	}
	,fill: function(amount) {
		var _g = 0;
		var _g1 = amount;
		while(_g < _g1) {
			var i = _g++;
			var node = this.create();
			node.next = this.head;
			this.head = node;
			this.size++;
		}
	}
	,getSize: function() {
		return this.size;
	}
	,clear: function() {
		this.head = null;
		this.size = 0;
	}
	,create: function() {
		throw new js__$Boot_HaxeError("Using abstract pool create()");
	}
};
var astar_cache_CachedPathPool = function() {
	astar_types_Pool_$astar_$cache_$CachedPath.call(this);
};
astar_cache_CachedPathPool.__super__ = astar_types_Pool_$astar_$cache_$CachedPath;
astar_cache_CachedPathPool.prototype = $extend(astar_types_Pool_$astar_$cache_$CachedPath.prototype,{
	getSolvedCachedPath: function(start,end,hash) {
		var path;
		if(this.head == null) {
			path = new astar_cache_CachedPath();
		} else {
			var node = this.head;
			this.head = this.head.next;
			node.next = null;
			this.size--;
			node.reset();
			path = node;
		}
		path.startX = start.x;
		path.startY = start.y;
		path.endX = end.x;
		path.endY = end.y;
		path.startNode = start;
		path.hash = hash;
		return path;
	}
	,getNoSolutionCachedPath: function(startX,startY,endX,endY,hash) {
		var path;
		if(this.head == null) {
			path = new astar_cache_CachedPath();
		} else {
			var node = this.head;
			this.head = this.head.next;
			node.next = null;
			this.size--;
			node.reset();
			path = node;
		}
		path.startX = startX;
		path.startY = startY;
		path.endX = endX;
		path.endY = endY;
		path.startNode = null;
		path.hash = hash;
		return path;
	}
	,create: function() {
		return new astar_cache_CachedPath();
	}
});
var astar_cache_PathCache = function(size) {
	if(size == null) {
		size = 100;
	}
	this.hits = 0;
	this.misses = 0;
	this.cache = new astar_cache_BubbleList_$astar_$cache_$CachedPath(size);
	this.cacheHashMap = new haxe_ds_IntMap();
	this.cachedPathPool = new astar_cache_CachedPathPool();
	this.cachedPathNodePool = new astar_cache_CachedPathNodePool();
};
astar_cache_PathCache.hash = function(x1,y1,x2,y2) {
	var h = 0;
	h += x1;
	h *= 37;
	h += y1;
	h *= 37;
	h += x2;
	h *= 37;
	h += y2;
	h *= 37;
	if(h < 0) {
		return -h;
	} else {
		return h;
	}
};
astar_cache_PathCache.prototype = {
	solve: function(startX,startY,endX,endY,result) {
		var h = 0;
		h += startX;
		h *= 37;
		h += startY;
		h *= 37;
		h += endX;
		h *= 37;
		h += endY;
		h *= 37;
		var hash = h < 0 ? -h : h;
		var cachedPath = this.cacheHashMap.h[hash];
		if(cachedPath == null) {
			this.misses++;
			return 1;
		}
		if(!(cachedPath.startX == startX && cachedPath.startY == startY && cachedPath.endX == endX && cachedPath.endY == endY)) {
			this.misses++;
			return 1;
		}
		this.hits++;
		this.cache.bubble(cachedPath);
		if(cachedPath.startNode == null) {
			return 2;
		}
		result.appendCachedNodes(cachedPath.startNode);
		return 0;
	}
	,addSolution: function(end) {
		var _this = this.cachedPathNodePool;
		var x = end.x;
		var y = end.y;
		var node;
		if(_this.head == null) {
			node = new astar_cache_CachedPathNode();
		} else {
			var node1 = _this.head;
			_this.head = _this.head.next;
			node1.next = null;
			_this.size--;
			node1.next = null;
			node = node1;
		}
		node.x = x;
		node.y = y;
		node.costToEnd = 0;
		node.next = null;
		var endNode = node;
		var iter = end;
		var next = endNode;
		while(iter.previous != null) {
			var costToEnd = iter.costFromStart - iter.previous.costFromStart + next.costToEnd;
			iter = iter.previous;
			var _this1 = this.cachedPathNodePool;
			var x1 = iter.x;
			var y1 = iter.y;
			var node2;
			if(_this1.head == null) {
				node2 = new astar_cache_CachedPathNode();
			} else {
				var node3 = _this1.head;
				_this1.head = _this1.head.next;
				node3.next = null;
				_this1.size--;
				node3.next = null;
				node2 = node3;
			}
			node2.x = x1;
			node2.y = y1;
			node2.costToEnd = costToEnd;
			node2.next = next;
			var node4 = node2;
			var h = 0;
			h += node4.x;
			h *= 37;
			h += node4.y;
			h *= 37;
			h += endNode.x;
			h *= 37;
			h += endNode.y;
			h *= 37;
			var hash = h < 0 ? -h : h;
			var _this2 = this.cachedPathPool;
			var path;
			if(_this2.head == null) {
				path = new astar_cache_CachedPath();
			} else {
				var node5 = _this2.head;
				_this2.head = _this2.head.next;
				node5.next = null;
				_this2.size--;
				node5.reset();
				path = node5;
			}
			path.startX = node4.x;
			path.startY = node4.y;
			path.endX = endNode.x;
			path.endY = endNode.y;
			path.startNode = node4;
			path.hash = hash;
			var path1 = path;
			if(this.cacheHashMap.h[path1.hash] != null) {
				var hash1 = path1.hash;
				var path2 = this.cacheHashMap.h[hash1];
				var _this3 = this.cache;
				if(_this3.head == null) {
					throw new js__$Boot_HaxeError("Removing from empty list.");
				} else if(_this3.tail == _this3.head) {
					_this3.length = 0;
					_this3.head = null;
					_this3.middle = null;
					_this3.tail = null;
				} else {
					_this3.length--;
					if(path2.previous != null) {
						path2.previous.next = path2.next;
					}
					if(path2.next != null) {
						path2.next.previous = path2.previous;
					}
					if(path2 == _this3.tail) {
						if(_this3.length % 2 == 0) {
							_this3.middle = _this3.middle.previous;
						}
					} else if(path2 == _this3.middle) {
						_this3.middle = _this3.middle.next;
					} else if(_this3.length % 2 == 0) {
						_this3.middle = _this3.middle.previous;
					} else {
						_this3.middle = _this3.middle.next;
					}
					if(path2 == _this3.tail) {
						_this3.tail = path2.previous;
					}
					if(path2 == _this3.head) {
						_this3.head = path2.next;
					}
				}
				path2.next = path2.previous = null;
				var v = null;
				this.cacheHashMap.h[hash1] = v;
				var _this4 = this.cachedPathPool;
				path2.next = _this4.head;
				_this4.head = path2;
				_this4.size++;
				path2.startNode = null;
			}
			var _this5 = this.cache;
			if(_this5.head == null) {
				_this5.head = path1;
				_this5.middle = path1;
				_this5.tail = path1;
				path1.next = path1.previous = null;
			} else {
				if(_this5.length % 2 == 1) {
					var a = _this5.middle.previous;
					var b = _this5.middle;
					path1.previous = a;
					if(a != null) {
						a.next = path1;
					}
					path1.next = b;
					if(b != null) {
						b.previous = path1;
					}
					if(path1.previous == null) {
						_this5.head = path1;
					}
					if(path1.next == null) {
						_this5.tail = path1;
					}
				} else {
					var a1 = _this5.middle;
					var b1 = _this5.middle.next;
					path1.previous = a1;
					if(a1 != null) {
						a1.next = path1;
					}
					path1.next = b1;
					if(b1 != null) {
						b1.previous = path1;
					}
					if(path1.previous == null) {
						_this5.head = path1;
					}
					if(path1.next == null) {
						_this5.tail = path1;
					}
				}
				_this5.middle = path1;
			}
			_this5.length++;
			var popped;
			if(_this5.length > _this5.capacity) {
				var popped1;
				if(_this5.tail == null) {
					popped1 = null;
				} else {
					var elem = _this5.tail;
					if(_this5.head == null) {
						throw new js__$Boot_HaxeError("Removing from empty list.");
					} else if(_this5.tail == _this5.head) {
						_this5.length = 0;
						_this5.head = null;
						_this5.middle = null;
						_this5.tail = null;
					} else {
						_this5.length--;
						if(elem.previous != null) {
							elem.previous.next = elem.next;
						}
						if(elem.next != null) {
							elem.next.previous = elem.previous;
						}
						if(elem == _this5.tail) {
							if(_this5.length % 2 == 0) {
								_this5.middle = _this5.middle.previous;
							}
						} else if(elem == _this5.middle) {
							_this5.middle = _this5.middle.next;
						} else if(_this5.length % 2 == 0) {
							_this5.middle = _this5.middle.previous;
						} else {
							_this5.middle = _this5.middle.next;
						}
						if(elem == _this5.tail) {
							_this5.tail = elem.previous;
						}
						if(elem == _this5.head) {
							_this5.head = elem.next;
						}
					}
					elem.next = elem.previous = null;
					popped1 = elem;
				}
				popped = popped1;
			} else {
				popped = null;
			}
			if(popped != null) {
				var hash2 = popped.hash;
				var path3 = this.cacheHashMap.h[hash2];
				var _this6 = this.cache;
				if(_this6.head == null) {
					throw new js__$Boot_HaxeError("Removing from empty list.");
				} else if(_this6.tail == _this6.head) {
					_this6.length = 0;
					_this6.head = null;
					_this6.middle = null;
					_this6.tail = null;
				} else {
					_this6.length--;
					if(path3.previous != null) {
						path3.previous.next = path3.next;
					}
					if(path3.next != null) {
						path3.next.previous = path3.previous;
					}
					if(path3 == _this6.tail) {
						if(_this6.length % 2 == 0) {
							_this6.middle = _this6.middle.previous;
						}
					} else if(path3 == _this6.middle) {
						_this6.middle = _this6.middle.next;
					} else if(_this6.length % 2 == 0) {
						_this6.middle = _this6.middle.previous;
					} else {
						_this6.middle = _this6.middle.next;
					}
					if(path3 == _this6.tail) {
						_this6.tail = path3.previous;
					}
					if(path3 == _this6.head) {
						_this6.head = path3.next;
					}
				}
				path3.next = path3.previous = null;
				var v1 = null;
				this.cacheHashMap.h[hash2] = v1;
				var _this7 = this.cachedPathPool;
				path3.next = _this7.head;
				_this7.head = path3;
				_this7.size++;
				path3.startNode = null;
			}
			this.cacheHashMap.h[path1.hash] = path1;
			next = node4;
		}
	}
	,addNoSolution: function(startX,startY,endX,endY) {
		var h = 0;
		h += startX;
		h *= 37;
		h += startY;
		h *= 37;
		h += endX;
		h *= 37;
		h += endY;
		h *= 37;
		var hash = h < 0 ? -h : h;
		var _this = this.cachedPathPool;
		var path;
		if(_this.head == null) {
			path = new astar_cache_CachedPath();
		} else {
			var node = _this.head;
			_this.head = _this.head.next;
			node.next = null;
			_this.size--;
			node.reset();
			path = node;
		}
		path.startX = startX;
		path.startY = startY;
		path.endX = endX;
		path.endY = endY;
		path.startNode = null;
		path.hash = hash;
		var path1 = path;
		if(this.cacheHashMap.h[path1.hash] != null) {
			var hash1 = path1.hash;
			var path2 = this.cacheHashMap.h[hash1];
			var _this1 = this.cache;
			if(_this1.head == null) {
				throw new js__$Boot_HaxeError("Removing from empty list.");
			} else if(_this1.tail == _this1.head) {
				_this1.length = 0;
				_this1.head = null;
				_this1.middle = null;
				_this1.tail = null;
			} else {
				_this1.length--;
				if(path2.previous != null) {
					path2.previous.next = path2.next;
				}
				if(path2.next != null) {
					path2.next.previous = path2.previous;
				}
				if(path2 == _this1.tail) {
					if(_this1.length % 2 == 0) {
						_this1.middle = _this1.middle.previous;
					}
				} else if(path2 == _this1.middle) {
					_this1.middle = _this1.middle.next;
				} else if(_this1.length % 2 == 0) {
					_this1.middle = _this1.middle.previous;
				} else {
					_this1.middle = _this1.middle.next;
				}
				if(path2 == _this1.tail) {
					_this1.tail = path2.previous;
				}
				if(path2 == _this1.head) {
					_this1.head = path2.next;
				}
			}
			path2.next = path2.previous = null;
			var v = null;
			this.cacheHashMap.h[hash1] = v;
			var _this2 = this.cachedPathPool;
			path2.next = _this2.head;
			_this2.head = path2;
			_this2.size++;
			path2.startNode = null;
		}
		var _this3 = this.cache;
		if(_this3.head == null) {
			_this3.head = path1;
			_this3.middle = path1;
			_this3.tail = path1;
			path1.next = path1.previous = null;
		} else {
			if(_this3.length % 2 == 1) {
				var a = _this3.middle.previous;
				var b = _this3.middle;
				path1.previous = a;
				if(a != null) {
					a.next = path1;
				}
				path1.next = b;
				if(b != null) {
					b.previous = path1;
				}
				if(path1.previous == null) {
					_this3.head = path1;
				}
				if(path1.next == null) {
					_this3.tail = path1;
				}
			} else {
				var a1 = _this3.middle;
				var b1 = _this3.middle.next;
				path1.previous = a1;
				if(a1 != null) {
					a1.next = path1;
				}
				path1.next = b1;
				if(b1 != null) {
					b1.previous = path1;
				}
				if(path1.previous == null) {
					_this3.head = path1;
				}
				if(path1.next == null) {
					_this3.tail = path1;
				}
			}
			_this3.middle = path1;
		}
		_this3.length++;
		var popped;
		if(_this3.length > _this3.capacity) {
			var popped1;
			if(_this3.tail == null) {
				popped1 = null;
			} else {
				var elem = _this3.tail;
				if(_this3.head == null) {
					throw new js__$Boot_HaxeError("Removing from empty list.");
				} else if(_this3.tail == _this3.head) {
					_this3.length = 0;
					_this3.head = null;
					_this3.middle = null;
					_this3.tail = null;
				} else {
					_this3.length--;
					if(elem.previous != null) {
						elem.previous.next = elem.next;
					}
					if(elem.next != null) {
						elem.next.previous = elem.previous;
					}
					if(elem == _this3.tail) {
						if(_this3.length % 2 == 0) {
							_this3.middle = _this3.middle.previous;
						}
					} else if(elem == _this3.middle) {
						_this3.middle = _this3.middle.next;
					} else if(_this3.length % 2 == 0) {
						_this3.middle = _this3.middle.previous;
					} else {
						_this3.middle = _this3.middle.next;
					}
					if(elem == _this3.tail) {
						_this3.tail = elem.previous;
					}
					if(elem == _this3.head) {
						_this3.head = elem.next;
					}
				}
				elem.next = elem.previous = null;
				popped1 = elem;
			}
			popped = popped1;
		} else {
			popped = null;
		}
		if(popped != null) {
			var hash2 = popped.hash;
			var path3 = this.cacheHashMap.h[hash2];
			var _this4 = this.cache;
			if(_this4.head == null) {
				throw new js__$Boot_HaxeError("Removing from empty list.");
			} else if(_this4.tail == _this4.head) {
				_this4.length = 0;
				_this4.head = null;
				_this4.middle = null;
				_this4.tail = null;
			} else {
				_this4.length--;
				if(path3.previous != null) {
					path3.previous.next = path3.next;
				}
				if(path3.next != null) {
					path3.next.previous = path3.previous;
				}
				if(path3 == _this4.tail) {
					if(_this4.length % 2 == 0) {
						_this4.middle = _this4.middle.previous;
					}
				} else if(path3 == _this4.middle) {
					_this4.middle = _this4.middle.next;
				} else if(_this4.length % 2 == 0) {
					_this4.middle = _this4.middle.previous;
				} else {
					_this4.middle = _this4.middle.next;
				}
				if(path3 == _this4.tail) {
					_this4.tail = path3.previous;
				}
				if(path3 == _this4.head) {
					_this4.head = path3.next;
				}
			}
			path3.next = path3.previous = null;
			var v1 = null;
			this.cacheHashMap.h[hash2] = v1;
			var _this5 = this.cachedPathPool;
			path3.next = _this5.head;
			_this5.head = path3;
			_this5.size++;
			path3.startNode = null;
		}
		this.cacheHashMap.h[path1.hash] = path1;
	}
	,reset: function(freeMemory) {
		if(freeMemory == null) {
			freeMemory = false;
		}
		while(this.cache.length > 0) {
			var path = this.cache.tail;
			if(path.startNode != null) {
				if(path.startNode.next.next == null) {
					var _this = this.cachedPathNodePool;
					var node = path.startNode.next;
					node.next = _this.head;
					_this.head = node;
					_this.size++;
				}
				var _this1 = this.cachedPathNodePool;
				var node1 = path.startNode;
				node1.next = _this1.head;
				_this1.head = node1;
				_this1.size++;
			}
			var hash = path.hash;
			var path1 = this.cacheHashMap.h[hash];
			var _this2 = this.cache;
			if(_this2.head == null) {
				throw new js__$Boot_HaxeError("Removing from empty list.");
			} else if(_this2.tail == _this2.head) {
				_this2.length = 0;
				_this2.head = null;
				_this2.middle = null;
				_this2.tail = null;
			} else {
				_this2.length--;
				if(path1.previous != null) {
					path1.previous.next = path1.next;
				}
				if(path1.next != null) {
					path1.next.previous = path1.previous;
				}
				if(path1 == _this2.tail) {
					if(_this2.length % 2 == 0) {
						_this2.middle = _this2.middle.previous;
					}
				} else if(path1 == _this2.middle) {
					_this2.middle = _this2.middle.next;
				} else if(_this2.length % 2 == 0) {
					_this2.middle = _this2.middle.previous;
				} else {
					_this2.middle = _this2.middle.next;
				}
				if(path1 == _this2.tail) {
					_this2.tail = path1.previous;
				}
				if(path1 == _this2.head) {
					_this2.head = path1.next;
				}
			}
			path1.next = path1.previous = null;
			var v = null;
			this.cacheHashMap.h[hash] = v;
			var _this3 = this.cachedPathPool;
			path1.next = _this3.head;
			_this3.head = path1;
			_this3.size++;
			path1.startNode = null;
		}
		if(freeMemory) {
			var _this4 = this.cachedPathPool;
			_this4.head = null;
			_this4.size = 0;
			var _this5 = this.cachedPathNodePool;
			_this5.head = null;
			_this5.size = 0;
		}
	}
	,configure: function(size) {
		this.cache = new astar_cache_BubbleList_$astar_$cache_$CachedPath(size);
	}
	,get_size: function() {
		return this.cache.capacity;
	}
	,addPath: function(path) {
		if(this.cacheHashMap.h[path.hash] != null) {
			var hash = path.hash;
			var path1 = this.cacheHashMap.h[hash];
			var _this = this.cache;
			if(_this.head == null) {
				throw new js__$Boot_HaxeError("Removing from empty list.");
			} else if(_this.tail == _this.head) {
				_this.length = 0;
				_this.head = null;
				_this.middle = null;
				_this.tail = null;
			} else {
				_this.length--;
				if(path1.previous != null) {
					path1.previous.next = path1.next;
				}
				if(path1.next != null) {
					path1.next.previous = path1.previous;
				}
				if(path1 == _this.tail) {
					if(_this.length % 2 == 0) {
						_this.middle = _this.middle.previous;
					}
				} else if(path1 == _this.middle) {
					_this.middle = _this.middle.next;
				} else if(_this.length % 2 == 0) {
					_this.middle = _this.middle.previous;
				} else {
					_this.middle = _this.middle.next;
				}
				if(path1 == _this.tail) {
					_this.tail = path1.previous;
				}
				if(path1 == _this.head) {
					_this.head = path1.next;
				}
			}
			path1.next = path1.previous = null;
			var v = null;
			this.cacheHashMap.h[hash] = v;
			var _this1 = this.cachedPathPool;
			path1.next = _this1.head;
			_this1.head = path1;
			_this1.size++;
			path1.startNode = null;
		}
		var _this2 = this.cache;
		if(_this2.head == null) {
			_this2.head = path;
			_this2.middle = path;
			_this2.tail = path;
			path.next = path.previous = null;
		} else {
			if(_this2.length % 2 == 1) {
				var a = _this2.middle.previous;
				var b = _this2.middle;
				path.previous = a;
				if(a != null) {
					a.next = path;
				}
				path.next = b;
				if(b != null) {
					b.previous = path;
				}
				if(path.previous == null) {
					_this2.head = path;
				}
				if(path.next == null) {
					_this2.tail = path;
				}
			} else {
				var a1 = _this2.middle;
				var b1 = _this2.middle.next;
				path.previous = a1;
				if(a1 != null) {
					a1.next = path;
				}
				path.next = b1;
				if(b1 != null) {
					b1.previous = path;
				}
				if(path.previous == null) {
					_this2.head = path;
				}
				if(path.next == null) {
					_this2.tail = path;
				}
			}
			_this2.middle = path;
		}
		_this2.length++;
		var popped;
		if(_this2.length > _this2.capacity) {
			var popped1;
			if(_this2.tail == null) {
				popped1 = null;
			} else {
				var elem = _this2.tail;
				if(_this2.head == null) {
					throw new js__$Boot_HaxeError("Removing from empty list.");
				} else if(_this2.tail == _this2.head) {
					_this2.length = 0;
					_this2.head = null;
					_this2.middle = null;
					_this2.tail = null;
				} else {
					_this2.length--;
					if(elem.previous != null) {
						elem.previous.next = elem.next;
					}
					if(elem.next != null) {
						elem.next.previous = elem.previous;
					}
					if(elem == _this2.tail) {
						if(_this2.length % 2 == 0) {
							_this2.middle = _this2.middle.previous;
						}
					} else if(elem == _this2.middle) {
						_this2.middle = _this2.middle.next;
					} else if(_this2.length % 2 == 0) {
						_this2.middle = _this2.middle.previous;
					} else {
						_this2.middle = _this2.middle.next;
					}
					if(elem == _this2.tail) {
						_this2.tail = elem.previous;
					}
					if(elem == _this2.head) {
						_this2.head = elem.next;
					}
				}
				elem.next = elem.previous = null;
				popped1 = elem;
			}
			popped = popped1;
		} else {
			popped = null;
		}
		if(popped != null) {
			var hash1 = popped.hash;
			var path2 = this.cacheHashMap.h[hash1];
			var _this3 = this.cache;
			if(_this3.head == null) {
				throw new js__$Boot_HaxeError("Removing from empty list.");
			} else if(_this3.tail == _this3.head) {
				_this3.length = 0;
				_this3.head = null;
				_this3.middle = null;
				_this3.tail = null;
			} else {
				_this3.length--;
				if(path2.previous != null) {
					path2.previous.next = path2.next;
				}
				if(path2.next != null) {
					path2.next.previous = path2.previous;
				}
				if(path2 == _this3.tail) {
					if(_this3.length % 2 == 0) {
						_this3.middle = _this3.middle.previous;
					}
				} else if(path2 == _this3.middle) {
					_this3.middle = _this3.middle.next;
				} else if(_this3.length % 2 == 0) {
					_this3.middle = _this3.middle.previous;
				} else {
					_this3.middle = _this3.middle.next;
				}
				if(path2 == _this3.tail) {
					_this3.tail = path2.previous;
				}
				if(path2 == _this3.head) {
					_this3.head = path2.next;
				}
			}
			path2.next = path2.previous = null;
			var v1 = null;
			this.cacheHashMap.h[hash1] = v1;
			var _this4 = this.cachedPathPool;
			path2.next = _this4.head;
			_this4.head = path2;
			_this4.size++;
			path2.startNode = null;
		}
		this.cacheHashMap.h[path.hash] = path;
	}
	,freePath: function(hash) {
		var path = this.cacheHashMap.h[hash];
		var _this = this.cache;
		if(_this.head == null) {
			throw new js__$Boot_HaxeError("Removing from empty list.");
		} else if(_this.tail == _this.head) {
			_this.length = 0;
			_this.head = null;
			_this.middle = null;
			_this.tail = null;
		} else {
			_this.length--;
			if(path.previous != null) {
				path.previous.next = path.next;
			}
			if(path.next != null) {
				path.next.previous = path.previous;
			}
			if(path == _this.tail) {
				if(_this.length % 2 == 0) {
					_this.middle = _this.middle.previous;
				}
			} else if(path == _this.middle) {
				_this.middle = _this.middle.next;
			} else if(_this.length % 2 == 0) {
				_this.middle = _this.middle.previous;
			} else {
				_this.middle = _this.middle.next;
			}
			if(path == _this.tail) {
				_this.tail = path.previous;
			}
			if(path == _this.head) {
				_this.head = path.next;
			}
		}
		path.next = path.previous = null;
		var v = null;
		this.cacheHashMap.h[hash] = v;
		var _this1 = this.cachedPathPool;
		path.next = _this1.head;
		_this1.head = path;
		_this1.size++;
		path.startNode = null;
	}
	,get: function(hash) {
		return this.cacheHashMap.h[hash];
	}
};
var astar_cost_DiagonalDistance = function(lateralFactor,diagonalFactor) {
	if(diagonalFactor == null) {
		diagonalFactor = 1.41421356;
	}
	if(lateralFactor == null) {
		lateralFactor = 1;
	}
	this.lateralFactor = lateralFactor;
	this.diagonalFactor = diagonalFactor;
};
astar_cost_DiagonalDistance.prototype = {
	getEstimate: function(fromX,fromY,toX,toY) {
		var dx = toX > fromX ? toX - fromX : fromX - toX;
		var dy = toY > fromY ? toY - fromY : fromY - toY;
		return this.lateralFactor * Math.max(dx,dy) + (this.diagonalFactor - this.lateralFactor) * Math.min(dx,dy);
	}
};
var astar_cost_ManhattanDistance = function(factor) {
	if(factor == null) {
		factor = 1;
	}
	this.factor = factor;
};
astar_cost_ManhattanDistance.prototype = {
	getEstimate: function(fromX,fromY,toX,toY) {
		var dx = toX > fromX ? toX - fromX : fromX - toX;
		var dy = toY > fromY ? toY - fromY : fromY - toY;
		return this.factor * (dx + dy);
	}
};
var astar_types__$Direction_Direction_$Impl_$ = {};
astar_types__$Direction_Direction_$Impl_$.dirX = function(this1) {
	switch(this1) {
	case 4:case 32:case 128:
		return 1;
	case 2:case 16:case 64:
		return -1;
	default:
		return 0;
	}
};
astar_types__$Direction_Direction_$Impl_$.dirY = function(this1) {
	switch(this1) {
	case 1:case 16:case 32:
		return 1;
	case 8:case 64:case 128:
		return -1;
	default:
		return 0;
	}
};
astar_types__$Direction_Direction_$Impl_$.isDiagonal = function(this1) {
	return (this1 & (16 | 32 | 64 | 128)) > 0;
};
var astar_types_PathNode = function() {
	this.adjacentCount = -1;
	this.discovered = this.visited = false;
	this.next = this.left = this.right = this.parent = null;
};
astar_types_PathNode.prototype = {
	reset: function() {
		this.adjacentCount = -1;
		this.discovered = this.visited = false;
		this.next = this.left = this.right = this.parent = null;
	}
	,getCostFromPrevious: function() {
		return this.costFromStart - this.previous.costFromStart;
	}
	,get_totalCost: function() {
		return this.costFromStart + this.estimatedCostToGoal;
	}
};
var astar_types_Pool_$astar_$types_$PathNode = function() {
	this.head = null;
	this.size = 0;
};
astar_types_Pool_$astar_$types_$PathNode.prototype = {
	get: function() {
		if(this.head == null) {
			return this.create();
		}
		var node = this.head;
		this.head = this.head.next;
		node.next = null;
		this.size--;
		node.adjacentCount = -1;
		node.discovered = node.visited = false;
		node.next = node.left = node.right = node.parent = null;
		return node;
	}
	,put: function(node) {
		node.next = this.head;
		this.head = node;
		this.size++;
	}
	,fill: function(amount) {
		var _g = 0;
		var _g1 = amount;
		while(_g < _g1) {
			var i = _g++;
			var node = this.create();
			node.next = this.head;
			this.head = node;
			this.size++;
		}
	}
	,getSize: function() {
		return this.size;
	}
	,clear: function() {
		this.head = null;
		this.size = 0;
	}
	,create: function() {
		throw new js__$Boot_HaxeError("Using abstract pool create()");
	}
};
var astar_types_PathNodePool = function() {
	astar_types_Pool_$astar_$types_$PathNode.call(this);
};
astar_types_PathNodePool.__super__ = astar_types_Pool_$astar_$types_$PathNode;
astar_types_PathNodePool.prototype = $extend(astar_types_Pool_$astar_$types_$PathNode.prototype,{
	getNode: function(x,y,costFromStart,costToGoal,previous) {
		var node;
		if(this.head == null) {
			node = new astar_types_PathNode();
		} else {
			var node1 = this.head;
			this.head = this.head.next;
			node1.next = null;
			this.size--;
			node1.adjacentCount = -1;
			node1.discovered = node1.visited = false;
			node1.next = node1.left = node1.right = node1.parent = null;
			node = node1;
		}
		node.x = x;
		node.y = y;
		node.costFromStart = costFromStart;
		node.estimatedCostToGoal = costToGoal;
		node.previous = previous;
		return node;
	}
	,create: function() {
		return new astar_types_PathNode();
	}
});
var astar_types_Pool = function() {
	this.head = null;
	this.size = 0;
};
astar_types_Pool.prototype = {
	get: function() {
		if(this.head == null) {
			return this.create();
		}
		var node = this.head;
		this.head = this.head.next;
		node.next = null;
		this.size--;
		node.reset();
		return node;
	}
	,put: function(node) {
		node.next = this.head;
		this.head = node;
		this.size++;
	}
	,fill: function(amount) {
		var _g = 0;
		var _g1 = amount;
		while(_g < _g1) {
			var i = _g++;
			var node = this.create();
			node.next = this.head;
			this.head = node;
			this.size++;
		}
	}
	,getSize: function() {
		return this.size;
	}
	,clear: function() {
		this.head = null;
		this.size = 0;
	}
	,create: function() {
		throw new js__$Boot_HaxeError("Using abstract pool create()");
	}
};
var astar_types_SortedPathNodeList = function() {
	var pool = null;
	if(pool != null) {
		this.clearRecursive(this.root,pool);
	}
	this.root = null;
	this.min = null;
	this.size = 0;
};
astar_types_SortedPathNodeList.prototype = {
	isEmpty: function() {
		return this.size == 0;
	}
	,clear: function(pool) {
		if(pool != null) {
			this.clearRecursive(this.root,pool);
		}
		this.root = null;
		this.min = null;
		this.size = 0;
	}
	,insert: function(node) {
		this.size++;
		if(this.root == null) {
			this.root = node;
			this.min = node;
			return;
		}
		var iter = this.root;
		while(iter != node) if(node.costFromStart + node.estimatedCostToGoal > iter.costFromStart + iter.estimatedCostToGoal) {
			if(iter.right == null) {
				node.parent = iter;
				iter.right = node;
				node.left = node.right = null;
			}
			iter = iter.right;
		} else {
			if(iter.left == null) {
				node.parent = iter;
				iter.left = node;
				node.left = node.right = null;
				if(iter == this.min) {
					this.min = node;
				}
			}
			iter = iter.left;
		}
	}
	,getNext: function() {
		return this.min;
	}
	,popNext: function() {
		if(this.min == null) {
			return null;
		}
		this.size--;
		var next = this.min;
		if(next == this.root) {
			this.root = next.right;
			if(this.root != null) {
				this.root.parent = null;
			}
			var iter = next.right;
			while(iter != null && iter.left != null) iter = iter.left;
			this.min = iter;
			return next;
		}
		if(next.right != null) {
			var parent = next.parent;
			var node = next.right;
			node.parent = parent;
			parent.left = node;
			var iter1 = next.right;
			while(iter1 != null && iter1.left != null) iter1 = iter1.left;
			this.min = iter1;
		} else {
			this.min = this.min.parent;
			this.min.left = null;
		}
		return next;
	}
	,remove: function(node) {
		if(this.root == null) {
			throw new js__$Boot_HaxeError("Cannot delete from an empty tree.");
		}
		if(node.parent == null && node.left == null && node.right == null) {
			if(node == this.root) {
				var pool = null;
				if(pool != null) {
					this.clearRecursive(this.root,pool);
				}
				this.root = null;
				this.min = null;
				this.size = 0;
			} else {
				throw new js__$Boot_HaxeError("Attempting to remove node not present in the tree?");
			}
		}
		if(node == this.min) {
			this.min = node.parent;
		}
		if(node.left == null && node.right == null) {
			if(node.parent != null) {
				if(node.parent.left == node) {
					node.parent.left = null;
				} else if(node.parent.right == node) {
					node.parent.right = null;
				}
			}
			node.parent = null;
		} else if(node.left == null) {
			var src = node.right;
			if(src.parent != null) {
				if(src.parent.left == src) {
					src.parent.left = null;
				} else if(src.parent.right == src) {
					src.parent.right = null;
				}
			}
			src.parent = null;
			src.parent = node.parent;
			if(node.parent == null) {
				this.root = src;
			} else if(node == node.parent.left) {
				src.parent.left = src;
			} else {
				src.parent.right = src;
			}
			node.parent = null;
		} else if(node.right == null) {
			var src1 = node.left;
			if(src1.parent != null) {
				if(src1.parent.left == src1) {
					src1.parent.left = null;
				} else if(src1.parent.right == src1) {
					src1.parent.right = null;
				}
			}
			src1.parent = null;
			src1.parent = node.parent;
			if(node.parent == null) {
				this.root = src1;
			} else if(node == node.parent.left) {
				src1.parent.left = src1;
			} else {
				src1.parent.right = src1;
			}
			node.parent = null;
		} else {
			var node1 = node;
			node1 = node1.right;
			while(node1.left != null) node1 = node1.left;
			var successor = node1;
			var successorParent = successor.parent;
			if(successorParent != node) {
				successorParent.left = successor.right;
			}
			if(successor.parent != null) {
				if(successor.parent.left == successor) {
					successor.parent.left = null;
				} else if(successor.parent.right == successor) {
					successor.parent.right = null;
				}
			}
			successor.parent = null;
			successor.parent = node.parent;
			if(node.parent == null) {
				this.root = successor;
			} else if(node == node.parent.left) {
				successor.parent.left = successor;
			} else {
				successor.parent.right = successor;
			}
			node.parent = null;
			successor.left = node.left;
			successor.right = node.right;
			if(successor.left != null) {
				successor.left.parent = successor;
			}
			if(successor.right != null) {
				successor.right.parent = successor;
			}
			node.left = node.right = null;
		}
		node.left = node.right = node.parent = null;
		this.size--;
	}
	,getSize: function() {
		return this.size;
	}
	,reparentNode: function(src,dst) {
		if(src.parent != null) {
			if(src.parent.left == src) {
				src.parent.left = null;
			} else if(src.parent.right == src) {
				src.parent.right = null;
			}
		}
		src.parent = null;
		src.parent = dst.parent;
		if(dst.parent == null) {
			this.root = src;
		} else if(dst == dst.parent.left) {
			src.parent.left = src;
		} else {
			src.parent.right = src;
		}
		dst.parent = null;
	}
	,replaceNode: function(src,dst) {
		if(src.parent != null) {
			if(src.parent.left == src) {
				src.parent.left = null;
			} else if(src.parent.right == src) {
				src.parent.right = null;
			}
		}
		src.parent = null;
		src.parent = dst.parent;
		if(dst.parent == null) {
			this.root = src;
		} else if(dst == dst.parent.left) {
			src.parent.left = src;
		} else {
			src.parent.right = src;
		}
		dst.parent = null;
		src.left = dst.left;
		src.right = dst.right;
		if(src.left != null) {
			src.left.parent = src;
		}
		if(src.right != null) {
			src.right.parent = src;
		}
		dst.left = dst.right = null;
	}
	,clearRecursive: function(node,pool) {
		if(node.left != null) {
			this.clearRecursive(node.left,pool);
		}
		if(node.right != null) {
			this.clearRecursive(node.right,pool);
		}
		node.next = pool.head;
		pool.head = node;
		pool.size++;
	}
	,findMin: function(startingNode) {
		var iter = startingNode;
		while(iter != null && iter.left != null) iter = iter.left;
		this.min = iter;
	}
	,addLeft: function(parent,node) {
		node.parent = parent;
		parent.left = node;
	}
	,addRight: function(parent,node) {
		node.parent = parent;
		parent.right = node;
	}
	,getInOrderSuccessorOf: function(node) {
		node = node.right;
		while(node.left != null) node = node.left;
		return node;
	}
	,removeFromParent: function(node) {
		if(node.parent != null) {
			if(node.parent.left == node) {
				node.parent.left = null;
			} else if(node.parent.right == node) {
				node.parent.right = null;
			}
		}
		node.parent = null;
	}
};
var astar_wrappers__$ClosedSet_ClosedSet_$Impl_$ = {};
astar_wrappers__$ClosedSet_ClosedSet_$Impl_$._new = function(width,height) {
	var this1 = [];
	return this1;
};
astar_wrappers__$ClosedSet_ClosedSet_$Impl_$.addNode = function(this1,node) {
	if(this1.length <= node.x) {
		this1.length = node.x + 1;
	}
	if(this1[node.x] == null) {
		this1[node.x] = [];
	}
	if(this1[node.x].length <= node.y) {
		this1[node.x].length = node.y + 1;
	}
	this1[node.x][node.y] = node;
};
astar_wrappers__$ClosedSet_ClosedSet_$Impl_$.contains = function(this1,x,y) {
	if(this1.length > x && this1[x] != null && this1[x].length > y) {
		return this1[x][y] != null;
	} else {
		return false;
	}
};
astar_wrappers__$ClosedSet_ClosedSet_$Impl_$.isDiscovered = function(this1,x,y) {
	if(this1.length > x && this1[x] != null && this1[x].length > y && this1[x][y] != null) {
		return this1[x][y].discovered;
	} else {
		return false;
	}
};
astar_wrappers__$ClosedSet_ClosedSet_$Impl_$.isVisited = function(this1,x,y) {
	if(this1.length > x && this1[x] != null && this1[x].length > y && this1[x][y] != null) {
		return this1[x][y].visited;
	} else {
		return false;
	}
};
astar_wrappers__$ClosedSet_ClosedSet_$Impl_$.get = function(this1,x,y) {
	return this1[x][y];
};
astar_wrappers__$ClosedSet_ClosedSet_$Impl_$.clear = function(this1,pool) {
	var _g = 0;
	var _g1 = this1.length;
	while(_g < _g1) {
		var x = _g++;
		if(this1[x] != null) {
			var _g2 = 0;
			var _g11 = this1[x].length;
			while(_g2 < _g11) {
				var y = _g2++;
				if(x < this1.length && this1[x] != null) {
					if(pool != null && this1[x][y] != null) {
						var node = this1[x][y];
						node.next = pool.head;
						pool.head = node;
						pool.size++;
					}
					this1[x][y] = null;
				}
			}
		}
	}
};
astar_wrappers__$ClosedSet_ClosedSet_$Impl_$.remove = function(this1,x,y,pool) {
	if(x < this1.length && this1[x] != null) {
		if(pool != null && this1[x][y] != null) {
			var node = this1[x][y];
			node.next = pool.head;
			pool.head = node;
			pool.size++;
		}
		this1[x][y] = null;
	}
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.prototype = {
	get: function(key) {
		return this.h[key];
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) (this.h.hasOwnProperty(key) ? a.push(key | 0) : null);
		return HxOverrides.iter(a);
	}
};
var haxe_iterators_MapKeyValueIterator = function(map) {
	this.map = map;
	this.keys = map.keys();
};
haxe_iterators_MapKeyValueIterator.prototype = {
	hasNext: function() {
		return this.keys.hasNext();
	}
	,next: function() {
		var key = this.keys.next();
		return { value : this.map.get(key), key : key};
	}
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var $_;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
astar_Graph.sqrt2 = Math.sqrt(2);
astar__$MovementDirection_MovementDirection_$Impl_$.FourWay = 1;
astar__$MovementDirection_MovementDirection_$Impl_$.EightWay = 2;
astar__$MovementDirection_MovementDirection_$Impl_$.EightWayHalfObstructed = 4;
astar__$MovementDirection_MovementDirection_$Impl_$.EightWayObstructed = 8;
astar_types_Pool_$astar_$cache_$CachedPathNode.__meta__ = { fields : { create : { IgnoreCover : null}}};
astar_types_Pool_$astar_$cache_$CachedPath.__meta__ = { fields : { create : { IgnoreCover : null}}};
astar_types__$Direction_Direction_$Impl_$.N = 1;
astar_types__$Direction_Direction_$Impl_$.W = 2;
astar_types__$Direction_Direction_$Impl_$.E = 4;
astar_types__$Direction_Direction_$Impl_$.S = 8;
astar_types__$Direction_Direction_$Impl_$.NW = 16;
astar_types__$Direction_Direction_$Impl_$.NE = 32;
astar_types__$Direction_Direction_$Impl_$.SW = 64;
astar_types__$Direction_Direction_$Impl_$.SE = 128;
astar_types_Pool_$astar_$types_$PathNode.__meta__ = { fields : { create : { IgnoreCover : null}}};
astar_types_Pool.__meta__ = { fields : { create : { IgnoreCover : null}}};
Main.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
